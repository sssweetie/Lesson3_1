# Что такое Git и зачем он нужен?

**_Git_** - это консольная утилита, для отслеживания и ведения истории изменения файлов, в вашем проекте. Чаще всего его используют для кода, но можно и для других файлов. Есть много различных способов использования Git. Помимо оригинального клиента, имеющего интерфейс командной строки, существует множество клиентов с графическим пользовательским интерфейсом, в той или иной степени реализующих функциональность Git.

# Настройка

Открываем терминал (Linux и MacOS) или консоль (Windows) и вводим следующие команды.

Установим имя для вашего пользователя
Вместо <ваше_имя> можно ввести, например, **Grisha_Popov**
Кавычки оставляем
**git config --global user.name "<ваше_имя>"**
Теперь установим email. Принцип тот же.
**git config --global user.email "<адрес_почты@email.com>"**

## Настройка ветки по умолчанию

Когда вы инициализируете репозиторий командой ***git init***, Git создаёт ветку с именем *master* по умолчанию. Начиная с версии 2.28, вы можете задать другое имя для создания ветки по умолчанию.

Например, чтобы установить имя main для вашей ветки по умолчанию, выполните следующую команду:

***git config --global init.defaultBranch main***

# Команды, используемые для работы с репозиторием

* **git init** инициализируем репозиторий

* **git status** - общий статус гита

* **git add <file_name>** добавить версионность файла

* **git add .** - добавить всем файлам версионность

* **git commit** фиксирование изменений

* **git commit -m"message"** фиксирование изменений напрямую в терменале

* **git commit -am "message"** фиксирование изменений в терменале напрямую без использования git add

* **git log** глянуть историю commit

* **git checkout master** вернутся в обычное состояние

* **(terminal powershell) new-item file.name** - создание нового файла

## Как получить помощь?

Если вам нужна помощь при использовании Git, есть три способа открыть страницу руководства по любой команде Git:

* ***git help <команда>***
* ***git <команда> --help***
* ***man git-<команда>***

Например, так можно открыть руководство по команде 
* ***git config***
* ***git help config***

Эти команды хороши тем, что ими можно пользоваться всегда, даже без подключения к сети.

# Процесс работы с Git
Не стоит после каждого изменения файла делать commit. Чаще всего их создают, когда:

* Создан новый функционал
* Добавлен новый блок на верстке
* Исправлены ошибки по коду
* Вы завершили рабочий день и хотите сохранить код

Это поможет держать вашу ветки в чистоте и порядке. Тем самым, вы будете видеть историю изменений по каждому нововведению в вашем проекте, а не по каждому файлу.

# Совместная работа (дополняем информацией с семинара 2)
Для этого вам пригодится ветвление

***Ветка*** - это набор *commit* (кружок), которые идут друг за другом. У ветки есть название, основную ветку чаще всего называют master (на картинках будет называться main) . Если говорить простыми словами, то ветка master - это наш проект.

Другие ветки - это отдельное место для реализации нового функционала или исправление багов (ошибок) нашего проекта. То есть, с отдельной веткой вы делаете что угодно, а затем сливаете эти изменения в основную ветку master.

***git branch*** - просмотр всех веток, текущая ветка выделена цветом.

Для того, чтобы создать новую ветку вводим:

***git branch <название_ветки>***

или вот так

***git checkout -b <название_ветки>***
создать новую ветку и сразу же в нее переместиться.

***git merge branch_name*** - соединить изменения из branch_name, с веткой, в которой мы находимся.

***git checkout branch_name*** - перемещение на ветку branch_name

***git branch -d name_branch*** удаление ветки

> Ветка master в Git ничем не отличается от остальных. Но она присутствует практически в каждом репозитории, потому что создается командой *git init* по умолчанию, 
а большинство пользователей не утруждают себя переименованием.
(C.Чакон, Б. Штрауб "Git для профессионального программиста")

[Для облегчения обучения, ссылка на бесплатный тренажер по Git](https://learngitbranching.js.org/)

[Справочные материалы по Markdown](https://learn.microsoft.com/ru-ru/contribute/markdown-reference)

# Работа с удаленными репозиториями.

## Создание Git-репозитория

Обычно вы получаете репозиторий Git одним из двух способов:

1. Вы можете взять локальный каталог, который в настоящее время не находится под версионным контролем, и превратить его в репозиторий Git, либо

2. Вы можете клонировать существующий репозиторий Git из любого места.

В обоих случаях вы получите готовый к работе Git репозиторий на вашем компьютере.

## Клонирование существующего репозитория

Для получения копии существующего Git-репозитория, например, проекта, в который вы хотите внести свой вклад, необходимо использовать команду ***git clone***. Если вы знакомы с другими системами контроля версий, такими как Subversion, то заметите, что команда называется «clone», а не «checkout». Это важное различие — вместо того, чтобы просто получить рабочую копию, Git получает копию практически всех данных, которые есть на сервере. При выполнении git clone с сервера забирается (pulled) каждая версия каждого файла из истории проекта. Фактически, если серверный диск выйдет из строя, вы можете использовать любой из клонов на любом из клиентов, для того, чтобы вернуть сервер в то состояние, в котором он находился в момент клонирования (вы можете потерять часть серверных хуков (server-side hooks) и т. п., но все данные, помещённые под версионный контроль, будут сохранены).

Клонирование репозитория осуществляется командой ***git clone <url>***. Например, если вы хотите клонировать библиотеку libgit2, вы можете сделать это следующим образом:

* ***git clone https://github.com/libgit2/libgit2***

## Получение изменений из удалённого репозитория — Fetch и Pull

Как вы только что узнали, для получения данных из удалённых проектов, следует выполнить:

* ***git fetch [remote-name]***
Данная команда связывается с указанным удалённым проектом и забирает все те данные проекта, которых у вас ещё нет. После того как вы выполнили команду, у вас должны появиться ссылки на все ветки из этого удалённого проекта, которые вы можете просмотреть или слить в любой момент.

Когда вы клонируете репозиторий, команда clone автоматически добавляет этот удалённый репозиторий под именем «origin». Таким образом, ***git fetch origin*** извлекает все наработки, отправленные на этот сервер после того, как вы его клонировали (или получили изменения с помощью fetch). Важно отметить, что команда git fetch забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы.

Если ветка настроена на отслеживание удалённой ветки, то вы можете использовать команду ***git pull*** чтобы автоматически получить изменения из удалённой ветки и слить их со своей текущей. Этот способ может для вас оказаться более простым или более удобным. К тому же, по умолчанию команда git clone автоматически настраивает вашу локальную ветку master на отслеживание удалённой ветки master на сервере, с которого вы клонировали репозиторий. Название веток может быть другим и зависит от ветки по умолчанию на сервере. Выполнение git pull, как правило, извлекает (fetch) данные с сервера, с которого вы изначально клонировали, и автоматически пытается слить (merge) их с кодом, над которым вы в данный момент работаете.

## Отправка изменений в удалённый репозиторий (Push)

Когда вы хотите поделиться своими наработками, вам необходимо отправить их в удалённый репозиторий. Команда для этого действия простая: ***git push <remote-name> <branch-name>***. Чтобы отправить вашу ветку master на сервер origin (повторимся, что клонирование обычно настраивает оба этих имени автоматически), вы можете выполнить следующую команду для отправки ваших коммитов:

* ***git push origin master***

Эта команда срабатывает только в случае, если вы клонировали с сервера, на котором у вас есть права на запись, и если никто другой с тех пор не выполнял команду push. Если вы и кто-то ещё одновременно клонируете, затем он выполняет команду push, а после него выполнить команду push попытаетесь вы, то ваш push точно будет отклонён. Вам придётся сначала получить изменения и объединить их с вашими и только после этого вам будет позволено выполнить push. Обратитесь к главе Ветвление в Git для более подробного описания, как отправлять изменения на удалённый сервер.

## Удаление и переименование удалённых репозиториев
Для переименования удалённого репозитория можно выполнить ***git remote rename.*** Например, если вы хотите переименовать pb в paul, вы можете это сделать при помощи git remote rename:

* ***git remote rename pb paul***
* ***git remote***
* ***origin***
* ***paul***

Стоит упомянуть, что это также изменит имена удалённых веток в вашем репозитории. То, к чему вы обращались как pb/master, теперь стало paul/master.

Если по какой-то причине вы хотите удалить удалённый репозиторий — вы сменили сервер или больше не используете определённое зеркало, или кто-то перестал вносить изменения — вы можете использовать git remote rm:

* ***git remote remove paul***
* ***git remote***
* ***origin***

При удалении ссылки на удалённый репозиторий все отслеживаемые ветки и настройки, связанные с этим репозиторием, так же будут удалены.